# 函数


Rust 程序至少包含一个 `main` 函数：

```rust
fn main() {
}
```

这有可能是最简单的函数声明了。我们前面提到过，`fn` 表明“这是一个函数”， 其后跟着函数名、
一个空的小括号(因为没有参数)，再然后是用花括号指明函数体。来看一个名为 `foo` 的函数：

```rust
fn foo() {
}
```

接下来，带参数的函数是什么样呢？来看这个打印数字的函数：

```rust
fn print_number(x: i32) {
    println!("x is: {}", x);
}
```

下面是一个使用 `print_number` 的完整程序：

```rust
fn main() {
    print_number(5);
}

fn print_number(x: i32) {
    println!("x is: {}", x);
}
```

可以看出，函数参数的声明方式和 `let` 很像，它是在函数名后面加个冒号，紧接着是其类型。

来看一个完整的程序，程序将两个数求和并打印结果：

```rust
fn main() {
    print_sum(5, 6);
}

fn print_sum(x: i32, y: i32) {
    println!("sum is: {}", x + y);
}
```

各参数间使用逗号分隔，不管是调用函数还是声明函数时。

和 `let` 不同的是，函数参数*必须*声明类型。下例无法运行：

```rust
fn print_sum(x, y) {
    println!("sum is: {}", x + y);
}
```

它会报错：

```rust
expected one of `!`, `:`, or `@`, found `)`
fn print_number(x, y) {
```

”强制声明参数类型“是经过慎重考虑的设计决策。尽管也可以进行全程序推断，但是有此特性的语言，例如Haskell，
却常建议用户在文档中明确指出类型，并以此作为最佳实践。我们认为，全推断和毫无推断的最佳平衡点是：
强制要求声明函数类型并允许在函数体内进行类型推断。

函数返回值是什么样子的呢？来看一个给整数加一的函数：

```rust
fn add_one(x: i32) -> i32 {
    x + 1
}
```

Rust只允许单一返回值，并在“箭头”后声明返回值类型。所谓“箭头”，是指一个破折号(`-`)紧跟着一个大于号(`>`)。
函数最后一行代表要返回的值，你会注意到，此处并没有分号。如果加了分号：


```rust
fn add_one(x: i32) -> i32 {
    x + 1;
}
```

将会出错：

```rust
error: not all control paths return a value
fn add_one(x: i32) -> i32 {
     x + 1;
}

help: consider removing this semicolon:
     x + 1;
          ^
```

该例子揭示了 Rust 中两件有趣的事情：Rust 是基于表达式的编程语言；
其分号的含义不同于其它基于“花括号和分号”的语言。此二者是有关联的。

## 表达式 vs 语句

Rust is primarily an expression-based language. There are only two kinds of statements, and everything else is an expression.

So what's the difference? Expressions return a value, and statements do not. That’s why we end up with ‘not all control paths return a value’ here: the statement x + 1; doesn’t return a value. There are two kinds of statements in Rust: ‘declaration statements’ and ‘expression statements’. Everything else is an expression. Let’s talk about declaration statements first.

In some languages, variable bindings can be written as expressions, not just statements. Like Ruby:

```rust
x = y = 5
```

In Rust, however, using let to introduce a binding is not an expression. The following will produce a compile-time error:

```rust
let x = (let y = 5); // expected identifier, found keyword `let`
```

The compiler is telling us here that it was expecting to see the beginning of an expression, and a let can only begin a statement, not an expression.

Note that assigning to an already-bound variable (e.g. y = 5) is still an expression, although its value is not particularly useful. Unlike other languages where an assignment evaluates to the assigned value (e.g. 5 in the previous example), in Rust the value of an assignment is an empty tuple ():


```rust
let mut y = 5;

let x = (y = 6);  // x has the value `()`, not `6`
```

The second kind of statement in Rust is the expression statement. Its purpose is to turn any expression into a statement. In practical terms, Rust's grammar expects statements to follow other statements. This means that you use semicolons to separate expressions from each other. This means that Rust looks a lot like most other languages that require you to use semicolons at the end of every line, and you will see semicolons at the end of almost every line of Rust code you see.

What is this exception that makes us say "almost"? You saw it already, in this code:


```rust
fn add_one(x: i32) -> i32 {
    x + 1
}
```

Our function claims to return an i32, but with a semicolon, it would return () instead. Rust realizes this probably isn’t what we want, and suggests removing the semicolon in the error we saw before.

## Early returns

But what about early returns? Rust does have a keyword for that, return:

```rust
fn foo(x: i32) -> i32 {
    return x;

    // we never run this code!
    x + 1
}
```

Using a return as the last line of a function works, but is considered poor style:

```rust
fn foo(x: i32) -> i32 {
    return x + 1;
}
```

The previous definition without return may look a bit strange if you haven’t worked in an expression-based language before, but it becomes intuitive over time.

## Diverging functions

Rust has some special syntax for ‘diverging functions’, which are functions that do not return:

```rust
fn diverges() -> ! {
    panic!("This function never returns!");
}
```

panic! is a macro, similar to println!() that we’ve already seen. Unlike println!(), panic!() causes the current thread of execution to crash with the given message.

Because this function will cause a crash, it will never return, and so it has the type ‘!’, which is read ‘diverges’. A diverging function can be used as any type:

let x: i32 = diverges();
let x: String = diverges();
