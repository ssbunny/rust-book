# 函数


Rust 程序至少包含一个 `main` 函数：

```rust
fn main() {
}
```

这有可能是最简单的函数声明了。我们前面提到过，`fn` 表明“这是一个函数”， 其后跟着函数名、
一个空的小括号(因为没有参数)，再然后是用花括号指明函数体。来看一个名为 `foo` 的函数：

```rust
fn foo() {
}
```

接下来，带参数的函数是什么样呢？来看这个打印数字的函数：

```rust
fn print_number(x: i32) {
    println!("x is: {}", x);
}
```

下面是一个使用 `print_number` 的完整程序：

```rust
fn main() {
    print_number(5);
}

fn print_number(x: i32) {
    println!("x is: {}", x);
}
```

可以看出，函数参数的声明方式和 `let` 很像，它是在函数名后面加个冒号，紧接着是其类型。

来看一个完整的程序，程序将两个数求和并打印结果：

```rust
fn main() {
    print_sum(5, 6);
}

fn print_sum(x: i32, y: i32) {
    println!("sum is: {}", x + y);
}
```

各参数间使用逗号分隔，不管是调用函数还是声明函数时。

和 `let` 不同的是，函数参数*必须*声明类型。下例无法运行：

```rust
fn print_sum(x, y) {
    println!("sum is: {}", x + y);
}
```

它会报错：

```rust
expected one of `!`, `:`, or `@`, found `)`
fn print_number(x, y) {
```

强制声明参数类型是经过慎重考虑的设计决策。尽管也可以进行全程序推断，但是有此特性的语言，例如Haskell，
却常建议用户在文档中明确指出类型，并以此作为最佳实践。我们认为，全推断和毫无推断的最佳平衡点是：
强制要求声明函数类型并允许在函数体内进行类型推断。

函数返回值是什么样子的呢？来看一个给整数加一的函数：

```rust
fn add_one(x: i32) -> i32 {
    x + 1
}
```

Rust只允许单一返回值，并在“箭头”后声明返回值类型。所谓“箭头”，是指一个破折号(`-`)紧跟着一个大于号(`>`)。
函数最后一行代表要返回的值，你会注意到，此处并没有分号。如果加了分号：


```rust
fn add_one(x: i32) -> i32 {
    x + 1;
}
```

将会出错：

```rust
error: not all control paths return a value
fn add_one(x: i32) -> i32 {
     x + 1;
}

help: consider removing this semicolon:
     x + 1;
          ^
```

该例子揭示了 Rust 中两件有趣的事情：Rust 是基于表达式的编程语言；
其分号的含义不同于其它基于“花括号和分号”的语言。此二者是有关联的。

## 表达式 vs 语句

首先，Rust 是基于表达式的语言，它只有两种类型的语句，其它皆为表达式。

那么，区别是什么？表达式有返回值，而语句没有。这正是程序以‘not all control paths return a value’
错误而中止的原因：语句 `x + 1;` 并不返回值。在 Rust 中有两种类型的语句："声明语句"和“表达式语句”。
其它一切均是表达式。先来看看声明语句。

在某些编程语言中，变量绑定可以被写成表达式的形式，而不只是语句。比如 Ruby ：

```ruby
x = y = 5
```

然而在 Rust 中，用 `let` 创建的绑定*并非*表达式。下列代码会产生编译期错误：

```rust
let x = (let y = 5); // expected identifier, found keyword `let`
```

编译器告诉我们，这里期望得到一个表达式，而 `let` 只能创建语句，不能创建表达式。

需要注意的是，给已绑定的变量(如 `y = 5`)赋值，得到的依然是表达式，尽管该表达式的值不是特别有用。
与那些将赋的值(如上例中的 `5`)作为赋值语句的值的编程语言不同，
Rust 赋值过程本身的返回值恒为空元组 `()` :


```rust
let mut y = 5;

let x = (y = 6);  // x 的值为 `()`, 而不是 `6`
```

Rust 中的第二类语句是*表达式语句*。它的目的是让表达式变成语句。
实际上，Rust 的语法要求使用语句接着语句，也就是说需要用分号将各表达式分隔开。
进一步说，看起来和大多数要求在行尾使用分号的语言一样，Rust 中几乎每行结尾都有一个分号。

既然是“几乎”，也就是说还有例外？当然喽，你已经见过了：

```rust
fn add_one(x: i32) -> i32 {
    x + 1
}
```

该函数要求返回 `i32` 类型的值，但如果加了分号，将会返回 `()` 。
Rust 发现这可能并不是我们想要的结果，于是在错误信息中建议我们删除分号，正如之前看到的一样。

## 提前返回

如何提前返回值呢？ Rust 为此提供了 `return` 关键字：

```rust
fn foo(x: i32) -> i32 {
    return x;

    // 此代码永远不会执行!
    x + 1
}
```

也可以在函数最后一行使用 `return`，但这是一种糟糕的代码风格：

```rust
fn foo(x: i32) -> i32 {
    return x + 1;
}
```

如果你以前从没用过基于表达式的语言，不使用 `return` 看起来确实会有点怪异，
但时间久了之后，便会觉得这样其实很直观。

## 发散函数

Rust有种特殊的语法，叫“发散函数”，是指一些没有返回值的函数：

```rust
fn diverges() -> ! {
    panic!("This function never returns!");
}
```

`panic!` 是个宏，和之前见到的 `println!()` 类似。与 `println!()` 不同的是，
`panic!()` 会致使当前执行的线程崩溃，并给出指定提示信息。

由于该函数会导致崩溃，因此永远不会有返回值，此时返回值类型为"`!`", 读作“发散”。
发散函数可用在任意类型中：

```rust
let x: i32 = diverges();
let x: String = diverges();
```
