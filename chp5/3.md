# åŸç”Ÿç±»å‹

Rust è¯­è¨€ä¸­ï¼Œæœ‰è®¸å¤šç±»å‹é€šè¿‡â€œåŸç”Ÿâ€çš„æ–¹å¼æä¾›ï¼Œæ„å‘³ç€è¿™äº›ç±»å‹æ˜¯è¯­è¨€çš„å†…å»ºç±»å‹ã€‚
åŒæ—¶ Rust æ ‡å‡†åº“ä¹Ÿä¼šåŸºäºå®ƒä»¬æ¥æä¾›å¾ˆå¤šå…¶å®ƒæœ‰ç”¨çš„ç±»å‹ï¼Œç„¶è€Œå®ƒä»¬æ›´åŠ åŸç”Ÿã€‚

## å¸ƒå°”

Rust æä¾›äº†å†…å»ºå¸ƒå°”ç±»å‹ï¼Œå«ä½œ `bool`ã€‚å®ƒæœ‰ä¸¤ä¸ªå€¼ï¼Œ `true` å’Œ `false` ï¼š

```rust
let x = true;

let y: bool = false;
```

å¸ƒå°”ç±»å‹é€šå¸¸ç”¨åœ¨[if æ¡ä»¶å¥](5.md)ä¸­ã€‚

å¯ä»¥åœ¨[æ ‡å‡†åº“æ–‡æ¡£](http://doc.rust-lang.org/stable/std/primitive.bool.html)
ä¸­æŸ¥çœ‹æ›´å¤šå…³äºå¸ƒå°”ç±»å‹çš„æ–‡æ¡£ã€‚

## char

`char` ç±»å‹ä»£è¡¨ä¸€ä¸ª Unicode å€¼ï¼Œå¯ä»¥ç”¨å•å¼•å·(`'`)åˆ›å»º `char`ï¼š

```rust
let x = 'x';
let two_hearts = 'ğŸ’•';
```

å’Œå…¶å®ƒä¸€äº›è¯­è¨€ä¸åŒï¼ŒRust çš„ `char` ä¸æ˜¯å•å­—èŠ‚ï¼Œè€Œæ˜¯å››ä¸ªå­—èŠ‚ã€‚

å¯ä»¥åœ¨[æ ‡å‡†åº“æ–‡æ¡£](http://doc.rust-lang.org/stable/std/primitive.char.html)
ä¸­æŸ¥çœ‹æ›´å¤šå…³äº char çš„æ–‡æ¡£ã€‚

## æ•°å­—ç±»å‹

Rust has a variety of numeric types in a few categories: signed and unsigned, fixed and variable, floating-point and integer.

These types consist of two parts: the category, and the size. For example, `u16` is an unsigned type with sixteen bits of size. More bits lets you have bigger numbers.

If a number literal has nothing to cause its type to be inferred, it defaults:

```rust
let x = 42; // x has type i32

let y = 1.0; // y has type f64
```

Hereâ€™s a list of the different numeric types, with links to their documentation in the standard library:

* i8
* i16
* i32
* i64
* u8
* u16
* u32
* u64
* isize
* usize
* f32
* f64

Letâ€™s go over them by category:

### Signed and Unsigned

Integer types come in two varieties: signed and unsigned. To understand the difference, letâ€™s consider a number with four bits of size. A signed, four-bit number would let you store numbers from -8 to +7. Signed numbers use â€œtwoâ€™s complement representationâ€. An unsigned four bit number, since it does not need to store negatives, can store values from 0 to +15.

Unsigned types use a u for their category, and signed types use i. The i is for â€˜integerâ€™. So u8 is an eight-bit unsigned number, and i8 is an eight-bit signed number.

### Fixed size types

Fixed size types have a specific number of bits in their representation. Valid bit sizes are 8, 16, 32, and 64. So, u32 is an unsigned, 32-bit integer, and i64 is a signed, 64-bit integer.

### Variable sized types

Rust also provides types whose size depends on the size of a pointer of the underlying machine. These types have â€˜sizeâ€™ as the category, and come in signed and unsigned varieties. This makes for two types: isize and usize.

### Floating-point types

Rust also has two floating point types: f32 and f64. These correspond to IEEE-754 single and double precision numbers.

## Arrays

Like many programming languages, Rust has list types to represent a sequence of things. The most basic is the array, a fixed-size list of elements of the same type. By default, arrays are immutable.

```rust
let a = [1, 2, 3]; // a: [i32; 3]
let mut m = [1, 2, 3]; // m: [i32; 3]
```

Arrays have type [T; N]. Weâ€™ll talk about this T notation in the generics section. The N is a compile-time constant, for the length of the array.

Thereâ€™s a shorthand for initializing each element of an array to the same value. In this example, each element of a will be initialized to 0:

```rust
let a = [0; 20]; // a: [i32; 20]
```

You can get the number of elements in an array a with a.len():

```rust
let a = [1, 2, 3];

println!("a has {} elements", a.len());
```


You can access a particular element of an array with subscript notation:

```rust
let names = ["Graydon", "Brian", "Niko"]; // names: [&str; 3]

println!("The second name is: {}", names[1]);
```

Subscripts start at zero, like in most programming languages, so the first name is names[0] and the second name is names[1]. The above example prints The second name is: Brian. If you try to use a subscript that is not in the array, you will get an error: array access is bounds-checked at run-time. Such errant access is the source of many bugs in other systems programming languages.

You can find more documentation for arrays in the standard library documentation.


## Slices






