# åŸç”Ÿç±»å‹

Rust è¯­è¨€ä¸­ï¼Œæœ‰è®¸å¤šç±»å‹é€šè¿‡â€œåŸç”Ÿâ€çš„æ–¹å¼æä¾›ï¼Œæ„å‘³ç€è¿™äº›ç±»å‹æ˜¯è¯­è¨€çš„å†…å»ºç±»å‹ã€‚
åŒæ—¶ Rust æ ‡å‡†åº“ä¹Ÿä¼šåŸºäºå®ƒä»¬æ¥æä¾›å¾ˆå¤šå…¶å®ƒæœ‰ç”¨çš„ç±»å‹ï¼Œç„¶è€Œå®ƒä»¬æ›´åŠ åŸç”Ÿã€‚

## å¸ƒå°”

Rust æä¾›äº†å†…å»ºå¸ƒå°”ç±»å‹ï¼Œå«åš `bool`ã€‚å®ƒæœ‰ä¸¤ä¸ªå€¼ï¼Œ `true` å’Œ `false` ï¼š

```rust
let x = true;

let y: bool = false;
```

å¸ƒå°”ç±»å‹é€šå¸¸ç”¨åœ¨[if æ¡ä»¶å¥](5.md)ä¸­ã€‚

å¯ä»¥åœ¨[æ ‡å‡†åº“æ–‡æ¡£](http://doc.rust-lang.org/stable/std/primitive.bool.html)
ä¸­æŸ¥çœ‹æ›´å¤šå…³äºå¸ƒå°”ç±»å‹çš„æ–‡æ¡£ã€‚

## char

`char` ç±»å‹ä»£è¡¨ä¸€ä¸ª Unicode å€¼ï¼Œå¯ä»¥ç”¨å•å¼•å·(`'`)åˆ›å»º `char`ï¼š

```rust
let x = 'x';
let two_hearts = 'ğŸ’•';
```

å’Œå…¶å®ƒä¸€äº›è¯­è¨€ä¸åŒï¼ŒRust çš„ `char` ä¸æ˜¯å•å­—èŠ‚ï¼Œè€Œæ˜¯å››ä¸ªå­—èŠ‚ã€‚

å¯ä»¥åœ¨[æ ‡å‡†åº“æ–‡æ¡£](http://doc.rust-lang.org/stable/std/primitive.char.html)
ä¸­æŸ¥çœ‹æ›´å¤šå…³äº char çš„æ–‡æ¡£ã€‚

## æ•°å­—ç±»å‹

Rust æœ‰å„å¼å„æ ·çš„æ•°å­—ç±»å‹ï¼Œå¤§è‡´åˆ†ä¸ºå‡ ä¸ªç§ç±»ï¼šæœ‰ç¬¦å·å’Œæ— ç¬¦å·çš„ï¼Œå›ºå®šå¤§å°å’Œå¯å˜å¤§å°çš„ï¼Œæµ®ç‚¹å’Œæ•´å‹çš„ã€‚

å®ƒä»¬ç”±ä¸¤ä¸ªéƒ¨åˆ†ç»„æˆï¼šç§ç±»åŠå¤§å°ã€‚ä¾‹å¦‚ï¼Œ `u16` çš„ç§ç±»ä¸ºæ— ç¬¦å·ï¼Œå¤§å°ä¸º16ä½ã€‚æ›´å¤šä½å¯ä»¥å­˜æ”¾æ›´å¤§çš„æ•°å­—ã€‚

å¦‚æœä¸æŒ‡å®šå­—é¢ç±»å‹ï¼Œå°†é‡‡ç”¨ç±»å‹æ¨æ–­ï¼Œé»˜è®¤æƒ…å†µä¸‹ï¼š

```rust
let x = 42; // x ä¸º i32 å‹

let y = 1.0; // y ä¸º f64 å‹
```

ä¸‹é¢åˆ—å‡ºäº†ä¸åŒçš„æ•°å­—ç±»å‹ï¼Œå¹¶é“¾å‘æ ‡å‡†åº“æ–‡æ¡£ï¼š

* [i8](http://doc.rust-lang.org/stable/std/primitive.i8.html)
* [i16](http://doc.rust-lang.org/stable/std/primitive.i16.html)
* [i32](http://doc.rust-lang.org/stable/std/primitive.i32.html)
* [i64](http://doc.rust-lang.org/stable/std/primitive.i64.html)
* [u8](http://doc.rust-lang.org/stable/std/primitive.u8.html)
* [u16](http://doc.rust-lang.org/stable/std/primitive.u16.html)
* [u32](http://doc.rust-lang.org/stable/std/primitive.u32.html)
* [u64](http://doc.rust-lang.org/stable/std/primitive.u64.html)
* [isize](http://doc.rust-lang.org/stable/std/primitive.isize.html)
* [usize](http://doc.rust-lang.org/stable/std/primitive.usize.html)
* [f32](http://doc.rust-lang.org/stable/std/primitive.f32.html)
* [f64](http://doc.rust-lang.org/stable/std/primitive.f64.html)

æˆ‘ä»¬å…ˆä»ç§ç±»å¼€å§‹çœ‹èµ·ï¼š

### æœ‰ç¬¦å·ä¸æ— ç¬¦å·

æ•´æ•°ç±»å‹æœ‰ä¸¤ç§ï¼šæœ‰ç¬¦å·çš„å’Œæ— ç¬¦å·çš„ã€‚ä¸ºäº†ç†è§£ä¸¤è€…çš„ä¸åŒï¼Œè¯·è€ƒè™‘ä¸€ä¸ªå››ä½å¤§å°çš„æ•°å­—ã€‚
å¦‚æœæ˜¯æœ‰ç¬¦å·çš„ï¼Œå››ä½æ•°å­—å¯ä»¥å­˜å‚¨ `-8` åˆ° `+7` ä¹‹é—´çš„æ•°ï¼Œæœ‰ç¬¦å·æ•°å­—ä½¿ç”¨â€œäºŒè¿›åˆ¶è¡¥ç è¡¨ç¤ºæ³•â€ã€‚
è¯¥å››ä½æ•°å­—å¦‚æœæ˜¯æ— ç¬¦å·çš„ï¼Œç”±äºä¸éœ€è¦å­˜å‚¨è´Ÿå·ï¼Œå®ƒå¯ä»¥å­˜å‚¨ `0` åˆ° `+15` ä¹‹é—´çš„æ•°å­—ã€‚

æ— ç¬¦å·ç±»å‹ä½¿ç”¨ `u` æ¥è¡¨ç¤ºï¼Œæœ‰ç¬¦å·ç±»å‹ä½¿ç”¨ `i` ã€‚`i` è¡¨ç¤º"integer"ã€‚
å› æ­¤ï¼Œ`u8` æ˜¯ä¸€ä¸ª8ä½çš„æ— ç¬¦å·æ•°å­—ï¼Œ`i8` åˆ™æ˜¯ä¸€ä¸ª8ä½çš„æœ‰ç¬¦å·æ•°å­—ã€‚

### å›ºå®šå¤§å°ç±»å‹

Fixed size types have a specific number of bits in their representation. Valid bit sizes are 8, 16, 32, and 64. So, u32 is an unsigned, 32-bit integer, and i64 is a signed, 64-bit integer.

### å¯å˜å¤§å°ç±»å‹

Rust also provides types whose size depends on the size of a pointer of the underlying machine. These types have â€˜sizeâ€™ as the category, and come in signed and unsigned varieties. This makes for two types: isize and usize.

### æµ®ç‚¹ç±»å‹

Rust also has two floating point types: f32 and f64. These correspond to IEEE-754 single and double precision numbers.

## Arrays

Like many programming languages, Rust has list types to represent a sequence of things. The most basic is the array, a fixed-size list of elements of the same type. By default, arrays are immutable.

```rust
let a = [1, 2, 3]; // a: [i32; 3]
let mut m = [1, 2, 3]; // m: [i32; 3]
```

Arrays have type [T; N]. Weâ€™ll talk about this T notation in the generics section. The N is a compile-time constant, for the length of the array.

Thereâ€™s a shorthand for initializing each element of an array to the same value. In this example, each element of a will be initialized to 0:

```rust
let a = [0; 20]; // a: [i32; 20]
```

You can get the number of elements in an array a with a.len():

```rust
let a = [1, 2, 3];

println!("a has {} elements", a.len());
```


You can access a particular element of an array with subscript notation:

```rust
let names = ["Graydon", "Brian", "Niko"]; // names: [&str; 3]

println!("The second name is: {}", names[1]);
```

Subscripts start at zero, like in most programming languages, so the first name is names[0] and the second name is names[1]. The above example prints The second name is: Brian. If you try to use a subscript that is not in the array, you will get an error: array access is bounds-checked at run-time. Such errant access is the source of many bugs in other systems programming languages.

You can find more documentation for arrays in the standard library documentation.


## Slices






