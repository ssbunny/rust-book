# 原生类型

Rust 语言中，有许多类型通过“原生”的方式提供，意味着这些类型是语言的内建类型。
同时 Rust 标准库也会基于它们来提供很多其它有用的类型，然而它们更加原生。

## 布尔

Rust 提供了内建布尔类型，叫作 `bool`。它有两个值， `true` 和 `false` ：

```rust
let x = true;

let y: bool = false;
```

布尔类型通常用在[if 条件句](5.md)中。

可以在[标准库文档](http://doc.rust-lang.org/stable/std/primitive.bool.html)
中查看更多关于布尔类型的文档。

## char

`char` 类型代表一个 Unicode 值，可以用单引号(`'`)创建 `char`：

```rust
let x = 'x';
let two_hearts = '💕';
```

和其它一些语言不同，Rust 的 `char` 不是单字节，而是四个字节。

可以在[标准库文档](http://doc.rust-lang.org/stable/std/primitive.char.html)
中查看更多关于 char 的文档。

## 数字类型

Rust has a variety of numeric types in a few categories: signed and unsigned, fixed and variable, floating-point and integer.

These types consist of two parts: the category, and the size. For example, `u16` is an unsigned type with sixteen bits of size. More bits lets you have bigger numbers.

If a number literal has nothing to cause its type to be inferred, it defaults:

```rust
let x = 42; // x has type i32

let y = 1.0; // y has type f64
```

Here’s a list of the different numeric types, with links to their documentation in the standard library:

* i8
* i16
* i32
* i64
* u8
* u16
* u32
* u64
* isize
* usize
* f32
* f64

Let’s go over them by category:

### Signed and Unsigned

Integer types come in two varieties: signed and unsigned. To understand the difference, let’s consider a number with four bits of size. A signed, four-bit number would let you store numbers from -8 to +7. Signed numbers use “two’s complement representation”. An unsigned four bit number, since it does not need to store negatives, can store values from 0 to +15.

Unsigned types use a u for their category, and signed types use i. The i is for ‘integer’. So u8 is an eight-bit unsigned number, and i8 is an eight-bit signed number.

### Fixed size types

Fixed size types have a specific number of bits in their representation. Valid bit sizes are 8, 16, 32, and 64. So, u32 is an unsigned, 32-bit integer, and i64 is a signed, 64-bit integer.

### Variable sized types

Rust also provides types whose size depends on the size of a pointer of the underlying machine. These types have ‘size’ as the category, and come in signed and unsigned varieties. This makes for two types: isize and usize.

### Floating-point types

Rust also has two floating point types: f32 and f64. These correspond to IEEE-754 single and double precision numbers.

## Arrays

Like many programming languages, Rust has list types to represent a sequence of things. The most basic is the array, a fixed-size list of elements of the same type. By default, arrays are immutable.

```rust
let a = [1, 2, 3]; // a: [i32; 3]
let mut m = [1, 2, 3]; // m: [i32; 3]
```

Arrays have type [T; N]. We’ll talk about this T notation in the generics section. The N is a compile-time constant, for the length of the array.

There’s a shorthand for initializing each element of an array to the same value. In this example, each element of a will be initialized to 0:

```rust
let a = [0; 20]; // a: [i32; 20]
```

You can get the number of elements in an array a with a.len():

```rust
let a = [1, 2, 3];

println!("a has {} elements", a.len());
```


You can access a particular element of an array with subscript notation:

```rust
let names = ["Graydon", "Brian", "Niko"]; // names: [&str; 3]

println!("The second name is: {}", names[1]);
```

Subscripts start at zero, like in most programming languages, so the first name is names[0] and the second name is names[1]. The above example prints The second name is: Brian. If you try to use a subscript that is not in the array, you will get an error: array access is bounds-checked at run-time. Such errant access is the source of many bugs in other systems programming languages.

You can find more documentation for arrays in the standard library documentation.


## Slices






